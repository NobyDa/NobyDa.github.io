{"pages":[],"posts":[{"title":"巴哈姆特自动签到脚本（适配&#x2F;开发实例）","text":"简介本文主要记录一次从巴哈姆特自动签到脚本（油猴）适配至可供Surge、QuantumultX运行的开发过程。 背景其实这个脚本很久之前就想适配Surge了，之前从Greasyfork搜到这个油猴签到脚本，但是该脚本只能在PC中打开巴哈姆特网页时才能被运行，如果不是每天都逛的话，很容易忘记签到，所以决定适配一下Surge。 当时脚本写了一半，前期测试时发现用户鉴权的Cookie有效期只有1天，这对于大多数自动化签到脚本来说都是致命的，意味着需要频繁去抓Cookie造成毫无使用体验。发现这一情况后并没有深入去研究，而且那段时间也比较忙，所以这个脚本一直处于停滞的状态。 最近在整理脚本时偶然发现这个未完成的脚本，想着可不能半途而废，于是决定深入研究一下巴哈姆特的鉴权方式，顺便分享一下整个过程。 过程签到脚本最重要的就是用户鉴权方式，一般来说大多数可以被写成脚本的签到都是请求头带上Cookie字段完成用户鉴权的过程，但该方法弊端很明显，例如有效期过短造成需要频繁的去抓取新Cookie。 而且除了上述情况之外，也不是所有APP/网页签到都可以写成脚本，例如相关请求被加密或者需要算法二次验证；这类情况也很难被写成自动化脚本。 幸运的是本文所描述的巴哈姆特签到并没有被加密，待解决的主要问题是每次签到开始时如何拿到最新的Cookie以避免签到过程中鉴权失败。 鉴权分析因为抓取的请求国内无法直连，使用Thor抓包的话需要路由级翻墙，多数用户并没有这个条件。本文为了方便读者实践，将使用Surge进行抓包，抓到以后导入Thor分析（因为有完善的关键字过滤且查看方便）最后使用Anubis进行重放演示。 既然我们无法使用已经生成好的Cookie，那么我们可以尝试抓取生成Cookie的接口，让脚本每一次运行时都去查询新Cookie，自然就解决了有效期问题。 抓包过程： 进入巴哈姆特动画疯APP后，退出登录 打开Surge，MITM主机名输入*:0表示解密所有域名以及所有端口，并开启抓取流量 进入巴哈姆特动画疯APP，输入账号密码登录 返回Surge，关闭抓取流量，并禁用*:0解密 抓到请求可以在Surge - 工具 - 已保存的截取数据中找到。 导入Thor： 我们导入Thor后，看到请求并不是很多，所以可以简单搜索一下请求URL关键字，例如我们想抓取登录请求，则尝试搜索login 搜索后有两条符合的请求，可能有的小伙伴就要问了，你怎么知道搜索这个关键字呢？ 答案是经验，抓的包多了，很自然就会知道相关请求的关键字，比如现在抓取的是登录请求，login即为登录的意思。如果关键字搜索不到，则只能凭经验逐条分析，没有什么特别好的办法。 回到正题，我们把搜索到的请求进一步查看请求体以及响应体。 吐槽：写这APP的程序员不行阿，怎么说用户密码也得加密一下。 登录请求体中，uid=为用户账号，passwd=为用户密码，以及各种验证码均以明文显示，响应体则是用户基本信息。 我们的需求是获取新Cookie，然后再看一下这个请求的响应头是否返回了Set-Cookie字段 可以看到响应头是有返回Set-Cookie的，但缺少了关键值，猜测可能是请求头中的Cookie已包含所以不返回。 我们右滑该请求，使用Anubis重放，把请求头中Cookie字段里的一些信息删掉，看看是否会返回完整的Set-Cookie 可以看到，删除请求头Cookie中的部分字段进行重放后，响应头的Set-Cookie返回了关键字段，该字段可用于签到的用户鉴权。 然后再进行重放，精简请求头、请求体的参数，看看哪些是必须的。 经过多次重放调试，可以得知： 请求头中Cookie里的ckBahamutCsrfToken字段需要与请求体中的bahamutCsrfToken字段对应 请求头中Cookie里的ckAPP_VCODE字段需要与请求体中的vcode字段对应 除账号密码和以上两个参数不可精简以外，其他都可删除 进一步重放后发现请求体中的vcode字段可以自定义，而bahamutCsrfToken字段不行， vcode字段我们暂且不管，bahamutCsrfToken字段的话，由于该脚本针对大众，如果多个用户使用同一个内容，可能会出现未知问题，所以得想个办法精简掉（虽然不精简也可以） 经过多次尝试无果后，灵光一现，想到了去Github搜索一下这个字段的关键字： 不得不说Github真是大佬聚集地，点进这个项目后可以看到是一个基于python的巴哈姆特签到项目（瞬间感觉上面抓包抓了个寂寞） 我们进一步查看源码后发现，登录拿Cookie的请求逻辑跟我调试时基本一致，但有几点不同 在他的源码中可以看到请求体并没有携带bahamutCsrfToken等参数，并且发现请求URL用的是v3接口，而我抓的是v4 瞬间豁然开朗，v3接口可以省略掉一些参数，经过重放调试后也可以正常返回Set-Cookie。 至此已经解决登录Cookie问题。 适配脚本脚本原型为适用于PC浏览器的巴哈姆特签到脚本 (油猴)，项目地址：bahamut-auto-sign-script； 该脚本业务逻辑包括巴哈签到、巴哈公会签到、动画疯答题等。 得益于该项目，省去了自行抓包分析签到等各种过程，在此表示感谢。 应用兼容脚本将适配多平台，脚本的写法需要同时兼容多个客户端，那么我们就需要一个兼容函数让它在不同环境下也能被正确执行. 本文将使用chavy大佬的兼容函数。项目地址：https://github.com/chavyleung/scripts/blob/master/Env.js 该兼容函数兼容大多数Surge、QuantumultX、Loon、Shadowrocket的内部API。 兼容函数 >folded123//太长了，略，可点击以上项目地址查看 全局变量写好兼容函数后我们先定义一些全局变量，供所有函数调用. 全局变量123456789101112131415161718// 以下全局变量中的持久化接口为BoxJs预留, 以便修改// 把兼容函数定义到$中, 以便统一调用const $ = new Env('巴哈姆特');// 用户名$.uid = $.getdata('@ND_BAHA.ID') || 'YourUserName';// 用户密码$.pwd = $.getdata('@ND_BAHA.PW') || 'YourUserPassword';// 是否自动签到公会，true/false，默认开启$.needSignGuild = $.getdata('@ND_BAHA.GUILD') || true;// 是否自动答题动画疯，true/false，默认开启 (不保证100%答题正确)$.needAnswer = $.getdata('@ND_BAHA.ANSWER') || true;// 为通知准备的空数组$.notifyMsg = []; 登录函数根据前面的分析，我们只需写一个登录请求即可拿到响应头中的Set-Cookie，请求成功后，后续客户端会自动设置其他同类域名请求的Cookie头字段，无需手动设置。如果登录失败，则终止执行脚本。 具体实现： 登录函数12345678910111213141516171819202122232425function BahamutLogin() { //登录函数，拿到Set-Cookie //登录成功: {&quot;success&quot;:true,&quot;userid&quot;:&quot;DGIE&quot;,&quot;nickname&quot;:&quot;coco&quot;,&quot;gold&quot;:152769,&quot;gp&quot;:0,&quot;avatar&quot;:&quot;https:\\/\\/avatar2.bahamut.com.tw\\/avataruserpic\\/dgie.png&quot;,&quot;avatar_s&quot;:&quot;https:\\/\\/avatar2.bahamut.com.tw\\/avataruserpic\\/dgie_s.png&quot;,&quot;lv&quot;:6} //账号错误: {&quot;code&quot;:0,&quot;message&quot;:&quot;查無此人：SDFOUGB&quot;} //密码错误: {&quot;code&quot;:0,&quot;message&quot;:&quot;帳號、密碼或驗證碼錯誤！&quot;} //验证码错误: {&quot;code&quot;:0,&quot;message&quot;:&quot;驗證碼錯誤&quot;} return $.http.post({ //使用post请求查询 (兼容函数实际上返回Promise实例对象,以便后续调用时可以实现顺序执行异步函数) url: 'https://api.gamer.com.tw/mobile_app/user/v3/do_login.php', //登录接口 headers: { //请求头 'Cookie': 'ckAPP_VCODE=6666' //Cookie中的ckAPP_VCODE为必须 }, //请求体放入用户名和密码，并把它uri编码 body: `uid=${encodeURIComponent($.uid)}&amp;passwd=${encodeURIComponent($.pwd)}&amp;vcode=6666` }) .then((resp) =&gt; { //请求成功的处理 const body = JSON.parse(resp.body); //解析响应体json为对象 if (body.userid) { //如果成功返回用户信息 $.log('', `✅巴哈姆特登录成功`); // 打印日志 } else { //否则登录失败 (例如密码错误) const failMsg = body.error ? body.error.message : null; //判断签到失败原因 throw new Error(`❌登录失败\\n❌${body.message||failMsg||'未知'}`); //带上原因抛出异常, 脚本结束 } }) //未写catch，如果登录失败，例如无法联网、密码错误等, 则被调用该函数时的catch捕获，脚本结束} 签到函数（巴哈）原油猴脚本的业务逻辑为先查询签到Token，再把拿到的Token去请求签到。 造好的轮子适配起来就是舒服，省了抓包；我们直接按照该逻辑去适配。 具体实现： 巴哈姆特签到函数123456789101112131415161718192021222324252627282930313233343536373839404142function BahamutSign() { //查询巴哈姆特签到Token return $.http.get({ //使用get方法 (Promise实例对象) 查询签到Token url: 'https://www.gamer.com.tw/ajax/get_csrf_token.php', // 查询Token接口 headers: {} //请求头, 客户端将自动设置Cookie字段 }).then(async (resp) =&gt; { //网络请求成功的处理, 实例函数带有async关键字, 表示里面有异步操作 if (resp.body) { //如果签到Token获取成功 $.log('', '✅获取签到令牌成功'); //打印日志 const sign = await StartSignBahamut(resp.body); //带上Token开始签到 $.notifyMsg.push(`主页签到: 成功, 已连续签到${sign}天`); //添加到全局变量备用 (通知) } else { //否则抛出异常 throw new Error('获取签到令牌失败'); //带上原因被下面catch捕获 } }) .catch(err =&gt; { $.notifyMsg.push(`主页签到: ${err.message||err}`); //添加到全局变量备用 (通知) $.log('', `❌巴哈姆特签到失败`, `❌${err.message||err}`); }); // 捕获异常, 打印日志}function StartSignBahamut(token) { //巴哈姆特签到 //签到成功: {&quot;data&quot;:{&quot;days&quot;:1,&quot;dialog&quot;:&quot;&quot;,&quot;prjSigninDays&quot;:0}} //已签过: {&quot;error&quot;:{&quot;code&quot;:0,&quot;message&quot;:&quot;今天您已經簽到過了喔&quot;,&quot;status&quot;:&quot;&quot;,&quot;details&quot;:[]}} //未登录: {&quot;error&quot;:{&quot;code&quot;:401,&quot;message&quot;:&quot;尚未登入&quot;,&quot;status&quot;:&quot;NO_LOGIN&quot;,&quot;details&quot;:[]}} //令牌过期: {&quot;error&quot;:{&quot;code&quot;:403,&quot;message&quot;:&quot;網頁已過期&quot;,&quot;status&quot;:&quot;CSRF_TOKEN_ERROR&quot;,&quot;details&quot;:[]}} return $.http.post({ //使用post方法 (Promise实例对象) 进行签到 url: 'https://www.gamer.com.tw/ajax/signin.php', //巴哈姆特签到接口 headers: {}, //请求头, 客户端将自动设置Cookie字段 body: `action=1&amp;token=${token}` //请求体带上查询到的签到Token }) .then(res =&gt; { // 网络请求成功的处理 const body = JSON.parse(res.body); //解析响应体json为对象 if (body.data) { // 如果签到成功 (判断预期响应格式) $.log('', '✅巴哈姆特签到成功', `✅已连续签到${body.data.days}天`); //打印日志 return body.data.days; //返回签到天数 } else { //否则签到失败 const failMsg = body.error ? body.error.message : null; //判断签到失败原因 throw new Error(failMsg || body.message || '未知'); //带上原因抛出异常 } }); //未写catch，如果签到失败或其他错误，则被调用该函数时的catch捕获} 第一个函数被调用后，查询签到Token成功后则调用第二个函数；如果这俩任何一环出现错误，则直接跳过该签到，继续运行其他任务。 签到函数（公会）原油猴脚本的业务逻辑为先查询已加入公会的ID，再进行签到操作。 我们直接按照该逻辑去适配。 具体实现： 公会签到函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function BahamutGuildSign() { //巴哈姆特查询公会列表 if ($.needSignGuild === false || $.needSignGuild === 'false') { //如果用户选择不签到公会 return; //退出公会签到函数 } return $.http.get({ //使用get请求查询公会列表 (Promise实例对象) url: 'https://api.gamer.com.tw/ajax/common/topBar.php?type=forum', // 查询公会列表接口 headers: {} //请求头, 客户端将自动设置Cookie字段 }) .then(async (resp) =&gt; { //网络请求成功的处理, 实例函数带有async关键字, 表示里面有异步操作 const list = (resp.body.replace(/\\n/g, '').match(/guild\\.php\\?g?sn=\\d.+?&lt;\\/p&gt;/g) || []) //正则过滤公会列表大致内容 .map(n =&gt; { //使用map遍历每个大致内容 return { //返回包含公会ID和公会名称的对象 sn: n.split(/guild\\.php\\?g?sn=(\\d+)/)[1], //正则进一步提取公会ID name: n.split(/&lt;p&gt;(.+?)&lt;\\/p&gt;/)[1] //正则进一步提取公会名称 } }); if (list.length) { //过滤后, 如果包含公会列表 $.log('', `✅获取公会列表成功`); //打印日志 //按照公会数量进行并发签到, map结合Promise.all后可以实现并发签到并且都完成后才进行下一行操作 const sign = await Promise.all(list.map(StartSignGuild)); const sucs = sign.filter(n =&gt; n === 1).length; //过滤后得到成功数量 const fail = sign.filter(n =&gt; n === 0).length; //过滤后得到失败数量 //添加到全局变量备用 (通知) $.notifyMsg.push(`公会签到: ${sucs?`成功${sucs}个`:``}${sucs&amp;&amp;fail?`, `:``}${fail?`失败${fail}个`:``}`); } else { throw new Error('公会列表为空'); //无公会列表则抛出异常 } }) .catch(err =&gt; { //捕获异常, 打印日志 $.notifyMsg.push(`公会签到: ${err.message || err}`); //添加到全局变量备用 (通知) $.log('', `❌巴哈姆特公会签到失败`, `❌${err.message || err}`); //打印日志 });}function StartSignGuild(v) { //巴哈姆特公会签到 //签到成功: {&quot;ok&quot;:1,&quot;msg&quot;:&quot;本日簽到成功！獲得5貢獻度&quot;} //已签过: {&quot;error&quot;:1,&quot;msg&quot;:&quot;您今天已經簽到過了！&quot;} //公会ID错误: {&quot;error&quot;:1,&quot;msg&quot;:&quot;此公會社團不存在。&quot;} //未加入公会: {&quot;error&quot;:1,&quot;msg&quot;:&quot;你還不是成員，歡迎加入！&quot;} //未登录: {&quot;error&quot;:1,&quot;msg&quot;:&quot;請先登入&quot;} return $.http.post({ //使用post方法签到公会 (Promise实例对象) url: 'https://guild.gamer.com.tw/ajax/guildSign.php', //公会签到接口 headers: {}, //请求头, 客户端将自动设置Cookie字段 body: `sn=${v.sn}` //把查询到的公会ID放进请求体 }) .then((res) =&gt; { //网络请求成功后的处理 const body = JSON.parse(res.body); //解析响应体json为对象 $.log('', `🔷&lt;${v.name}&gt;`, `${body.ok?`✅`:`❌`}${body.msg}`); //打印日志, 包含签到结果 if (body.ok) { //如果签到成功 return 1; //返回1表示成功 } else { return 0; //返回0表示失败 } }) .catch(e =&gt; { //捕获异常, 打印日志 $.log('', `🔷&lt;${v.name}&gt;`, `❌签到失败: ${e.message||e}`); return 0; //返回0表示失败 });} 第一个函数被调用后，首先判断用户是否开启公会签到，如果开启则先查询已加入公会的ID，查询成功后再调用第二个函数并发签到。 如果用户选择关闭公会签到或者查询公会ID失败，则直接退出该签到，继续运行其他任务。 答题函数（动画疯）原油猴脚本的答题逻辑稍微有点复杂，简单概括就是默认手动答题 (浏览器)，如果开启自动答题，则先查询题目，查询成功后： 从blackxblue的小屋获取今日答案的文章ID 如果找到文章ID，则查询该文章内容找到答案 如果以上获取失败，则调用moontai0724的题库寻找答案（耗时过长） 所以我们适配时将直接从blackxblue的小屋获取答案，获取失败则跳过该任务 具体实现： 动画疯答题函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394function BahamutAnswer() { //动画疯答题 //未答题: {&quot;game&quot;:&quot;灌籃高手&quot;,&quot;question&quot;:&quot;流川楓的號碼是下列何者？&quot;,&quot;a1&quot;:&quot;7&quot;,&quot;a2&quot;:&quot;11&quot;,&quot;a3&quot;:&quot;23&quot;,&quot;a4&quot;:&quot;59&quot;,&quot;userid&quot;:&quot;GN32964174&quot;,&quot;token&quot;:&quot;01092fe463ab36ab47cb298e229c4f8fb298e229cc260fa7baf&quot;} //已答题: {&quot;error&quot;:1,&quot;msg&quot;:&quot;今日已經答過題目了，一天僅限一次機會&quot;} //未登录: {&quot;error&quot;:1,&quot;nologin&quot;:1,&quot;msg&quot;:&quot;請先登入&quot;} if ($.needAnswer === false || $.needAnswer === 'false') { //如果用户关闭动画疯答题 return; //退出答题函数 } return $.http.get({ //使用get方获取题目 (Promise实例对象) url: 'https://ani.gamer.com.tw/ajax/animeGetQuestion.php?t=' + Date.now(), //获取题目接口 headers: {} //请求头, 客户端将自动设置Cookie字段 }) .then(async (res) =&gt; { //网络请求成功的处理, 实例函数带有async关键字, 表示里面有异步操作 const r = JSON.parse(res.body); //解析响应体json为对象 if (r.token) { //如果有题目 $.log('', `✅获取动画疯题目成功`, ``, `🔶&lt;${r.game}&gt; ${r.question}`, `1️⃣${r.a1}`, `2️⃣${r.a2}`, `3️⃣${r.a3}`, `4️⃣${r.a4}`); //打印日志 const article = await GetAanswerArticles(); //获取答案文章ID const getAnswer = await StartSearchAnswers(article); //传入文章ID, 再从文章内获取答案 const sendAnswer = await StartBahamutAnswer(getAnswer, r.token); //传入答案和题目令牌, 开始答题 $.notifyMsg.push(`动画答题: ${sendAnswer}`); //答题后的结果添加到全局变量备用 (通知) } else { //未获取到题目 throw new Error(r.msg || `获取题目失败`); //带上原因抛出异常 } }) .catch(e =&gt; { //捕获异常, 打印日志 $.notifyMsg.push(`动画答题: ${e.message||e||`失败`}`); //添加到全局变量备用 (通知) $.log('', `❌动画疯答题失败`, `❌${e.message||e}`); //打印日志 });}function GetAanswerArticles() { // 从blackxblue的小屋查询含答案的文章ID $.log('', `🔶开始获取文章`); //打印日志 return $.http.get({ //使用get方法获取文章ID (Promise实例对象) url: 'https://api.gamer.com.tw/mobile_app/bahamut/v1/home.php?owner=blackXblue&amp;page=1', //获取文章ID接口 headers: {} }) .then((res) =&gt; { //网络请求成功后的处理 const body = JSON.parse(res.body); //解析响应体json为对象 const tDate = $.time('MM/dd'); //返回今日日期 const title = (body.creation || []).filter(t =&gt; t.title.includes(tDate)); //过滤后返回今日答案文章 if (title.length &amp;&amp; title[0].sn) { //如果有答案文章 $.log('', `✅获取文章成功 (${title[0].sn})`); //打印日志 return title[0].sn; //返回文章ID } else { //否则带上原因抛出异常, 被调用该函数时的catch捕获 throw new Error('今日答案未发表'); } })}function StartSearchAnswers(id) { //获取文章内答案 $.log('', `🔶开始获取答案`); //打印日志 return $.http.get({ //使用get方法获取答案 (Promise实例对象) url: 'https://api.gamer.com.tw/mobile_app/bahamut/v1/home_creation_detail.php?sn=' + id, //获取答案接口 headers: {} }) .then((res) =&gt; { //网络请求成功后的处理 const body = JSON.parse(res.body); //解析响应体json为对象 const answers = body.content.split(/A:(\\d)/)[1]; //正则提取答案 if (answers) { //如果成功提取答案 $.log('', `✅获取答案成功 (${answers})`); //打印日志 return answers; //返回答案 } else { //否则带上原因抛出异常, 被调用该函数时的catch捕获 throw new Error('提取答案失败'); } })}function StartBahamutAnswer(answer, token) { //动画疯答题 //答题正确: {&quot;ok&quot;:1,&quot;gift&quot;:&quot;恭喜您得到：300 巴幣&quot;} //答题错误: {&quot;error&quot;:1,&quot;msg&quot;:&quot;答題錯誤&quot;} //令牌过期: {&quot;error&quot;:1,&quot;msg&quot;:&quot;很抱歉！本題目已超過時效！&quot;} //已答题: {&quot;error&quot;:1,&quot;msg&quot;:&quot;今日已經答過題目了，一天僅限一次機會&quot;} //未登录: {&quot;error&quot;:1,&quot;nologin&quot;:1,&quot;msg&quot;:&quot;請先登入&quot;} $.log('', `🔶开始答题`); //打印日志 return $.http.post({ //使用post方法提交答案 (Promise实例对象) url: 'https://ani.gamer.com.tw/ajax/animeAnsQuestion.php', //提交答案接口 headers: {}, //请求头, 客户端将自动设置Cookie字段 body: `token=${token}&amp;ans=${answer}&amp;t=${Date.now()}`, //请求体带上答案和答案令牌 }) .then((res) =&gt; { //网络请求成功后的处理 const body = JSON.parse(res.body); //解析响应体json为对象 if (body.ok) { //如果答题成功 $.log('', `✅${body.gift}`); //打印奖励日志 return body.gift; //返回奖励内容 } else { //否则答题失败 const failMsg = body.error ? body.error.message : null; //提取签到失败原因 throw new Error(body.msg || failMsg || '未知'); //否则带上原因抛出异常, 被调用该函数时的catch捕获 } })} 共有四个函数，第一个函数被调用后首先查询题目，如果查询成功： 调用第二个函数从blackxblue的小屋查询今日答案的文章ID 调用第三个函数查询文章内的答案 调用第四个函数则进行答题 如果以上任一环节查询失败，则不会再继续执行其余函数，跳过动画疯答题。 统一调用写好函数后，如果不进行调用，那么代码是无法被运行的. 在javascript中，代码的执行顺序很重要，我们的需求是先完成一个任务后再进行下一个任务，最后退出脚本. 以下匿名函数将按我们预期的顺序执行. 匿名异步函数12345678910111213(async function() { // 立即运行的匿名异步函数 await BahamutLogin(); // 登录 await BahamutGuildSign(); //签到巴哈公会 await BahamutSign(); //签到巴哈 await BahamutAnswer(); //动画疯答题})().catch((e) =&gt; $.notifyMsg.push(e.message || e)) //捕获登录函数等抛出的异常, 并把原因添加到全局变量(通知) .finally(() =&gt; { //finally在catch之后无论有无异常都会执行 $.msg(`巴哈姆特`, ``, $.notifyMsg.join('\\n'), { 'open-url': 'crazyanime://', //动画疯url scheme 'media-url': 'https://cdn.jsdelivr.net/gh/NobyDa/mini@master/Color/bahamutClear.png' //通知图片 }); //带上总结推送通知 $.done(); //调用Surge、QX内部特有的函数, 用于退出脚本执行 }); 至此脚本适配已完成。 配置任务我们写好脚本后，就可以在Surge或QuantumultX里配置定时任务让它在规定时间内执行该脚本. 以下将用Surge进行演示 编辑Surge配置文件，在[Script]段落放入以下脚本 1巴哈姆特签到 = type=cron,cronexp=&quot;0 8 * * *&quot;,wake-system=1,timeout=30,script-path=https://raw.githubusercontent.com/NobyDa/Script/master/Bahamut/BahamutDailyBonus.js 以上配置将在每天的早上8:00执行。 有几点需要注意： 需要进入BoxJs填写账号密码，或者手动填入脚本（全局变量） 脚本不建议在凌晨执行（需要获取blackxblue发布的动画疯答案） 脚本兼容Surge、QuantumultX、Loon、Shadowrocket 以及 Node.js (需安装got、tough-cookie模块) 后记虽然油猴版巴哈姆特签到并非鄙人原创，但二次适配起来并不亚于重构整个脚本，脚本的逻辑也需要重新设计。 教学类型文章不可避免会有一些专业性，抓包部分对于初学者来说并不难，脚本部分也包含大量的注释供读者理解执行逻辑。 俗话说：授人以鱼不如授人以渔，授之以渔可解一生之需； 祝大家学成归来。","link":"/2021/07/24/Bahamut_daily_bonus_js_example/"},{"title":"记录一次Surge &amp; QuantumultX 脚本开发过程","text":"前言 本文主要记录一次Surge或QuantumultX的脚本开发过程, 过程包括抓包、分析、调试、以及编写脚本. 记录内容为哔哩哔哩漫画积分商城自动抢券脚本. 背景作为一个合格的二次元迷, 漫画当然是少不了🧐 国内日漫大多都被哔哩哔哩漫画拿下版权, 然而里面大多数的日漫都需要氪金或使用漫读券才能看; 最近发现使用签到脚本获得的积分囤得差不多了, 换漫读券又可以省一笔, 无奈老是错过相关商品兑换时间, 一气之写了个脚本让它在规定时间内自动抢券. 过程第一步: 抓包本文将使用Thor进行抓包, 并使用Anubis进行重放演示, 简单分析哔哩哔哩漫画的网络请求. 我们进入哔哩哔哩漫画APP后, 打开Thor开启抓包, 返回APP积分商城随便兑换一个东西, 再返回Thor关闭抓包. Thor有着完备的关键字过滤, 刚刚兑换了75积分的商品, 我们可以尝试搜索请求体和响应体内的关键字, 看看是否有结果. 搜索后一个名为Pointshop/Exchange的请求直接映入眼下, 翻译成中文大意为 店铺/兑换, 很直观. 我们进一步查看该请求的请求体, 以及响应体. 可以很直观的看到请求体中的各种参数, product_id 表示兑换的商品, product_num 表示兑换的数量, point 表示消耗的积分. 响应体中code为0表示兑换成功, expire_day表示有效期, remain_amount表示该商品库存. 我们把该请求使用anubis重放, 看看该接口是否有效. 可以看到重放后该接口是可用的, 商品剩余数量相应减少, 返回app查看账号积分也减少了75并收到商品. 之后我们看一下请求体中的product_id的商品id是怎么来的, 返回Thor之前抓到的包, 筛选器搜索1048关键字. 搜索后有一个叫ListProduct的请求, 翻译成中文大意为商品清单, 我们点开响应体可以看到一个商品名为”小智怪谈”的商品, 商品id为1048, 商品库存为3796, 正是我之前所兑换的商品. 该接口使用anubis重放后并没有什么问题; 最后还差一个查询账户积分的接口, 我们使用Thor筛选器搜索响应关键字, 开启抓包之前我的账户有3172积分, 则尝试搜索3172 可以看到有一个叫GetUserPoint的请求, 翻译成中文大意为获取用户积分, 点开响应后我们可以看到查询到的账户积分. 第二步: 分析我们抓到接口后使用anubis重放进一步分析: 精简参数, 分析url中的device之类的参数是否必须、是否验证Cookie、请求体是否必须, 以减少脚本编写工作量. 分析各种情况下接口返回不同响应的可能性, 供脚本正确判断. 分析查询积分接口12原接口https://manga.bilibili.com/twirp/pointshop.v1.Pointshop/GetUserPoint?device=h5&amp;platform=web 经过各种重放后可得知 接口可省略url中的参数. 请求体可省略. 必须使用POST方法. 使用请求头中的Cookie字段作为用户鉴权, 一些非必要字段也可省略. 带有效Cookie响应体内容为 1234567{ &quot;code&quot;: 0, &quot;msg&quot;: &quot;&quot;, &quot;data&quot;: { &quot;point&quot;: &quot;用户实际积分数量&quot; }} Cookie失效后响应体内容为 1234567{ &quot;code&quot;: 0, &quot;msg&quot;: &quot;&quot;, &quot;data&quot;: { &quot;point&quot;: &quot;0&quot; }} 分析查询商品接口12原接口https://manga.bilibili.com/twirp/pointshop.v1.Pointshop/ListProduct?device=h5&amp;platform=web 经过各种重放后可得知 接口可省略url中的参数. 请求体可省略. 必须使用POST方法. 无需用户鉴权. 响应体: 123456789101112131415161718192021222324252627{ &quot;code&quot;: 0, &quot;msg&quot;: &quot;&quot;, &quot;data&quot;: [{ &quot;id&quot;: 195, &quot;type&quot;: 7, &quot;title&quot;: &quot;积分兑换&quot;, &quot;image&quot;: &quot;&quot;, &quot;amount&quot;: 15999, &quot;cost&quot;: 200, &quot;real_cost&quot;: 100, &quot;remain_amount&quot;: 0, &quot;comic_id&quot;: 0, &quot;limits&quot;: [], &quot;discount&quot;: 0, &quot;product_type&quot;: 1, &quot;pendant_url&quot;: &quot;&quot;, &quot;pendant_expire&quot;: 0, &quot;exchange_limit&quot;: 0, &quot;address_deadline&quot;: &quot;0001-01-01T00:00:00Z&quot;, &quot;act_type&quot;: 0, &quot;has_exchanged&quot;: false, &quot;main_coupon_deadline&quot;: &quot;0001-01-01T00:00:00Z&quot;, &quot;deadline&quot;: &quot;&quot;, &quot;point&quot;: &quot;0&quot; }]} 以上非实际响应, 其他商品过多, 已省略. 分析兑换商品接口12原接口https://manga.bilibili.com/twirp/pointshop.v1.Pointshop/Exchange?device=h5&amp;platform=web 经过各种重放后可得知 接口可省略url中的参数. 请求体需带有 12345{ &quot;product_id&quot;: &quot;商品ID&quot;, &quot;product_num&quot;: &quot;商品兑换数量&quot;, &quot;point&quot;: &quot;总消耗积分数量&quot;} 必须使用POST方法. 使用请求头中的Cookie字段作为用户鉴权, 一些非必要字段也可省略. 兑换成功响应体内容为 12345678910{ &quot;code&quot;: 0, &quot;msg&quot;: &quot;&quot;, &quot;data&quot;: { &quot;id&quot;: &quot;商品使用ID&quot;, &quot;expire_day&quot;: &quot;商品过期剩余天&quot;, &quot;remain_amount&quot;: &quot;商品库存&quot;, &quot;deadline&quot;: &quot;0001-01-01T00:00:00Z&quot; }} 第三步: 编写脚本 什么是函数 函数是 JavaScript 中的基本组件之一, 一个函数是 JavaScript过程中执行一组任务或计算值的语句. 本文的抢券脚本将定义各种函数以方便统一调用. 查看 JavaScript 函数详细参考文档 了解更多. 应用兼容由于该脚本针对多平台, 脚本的写法需要同时兼容Surge或QuanX之类的客户端, 那么我们就需要写一个兼容函数让它在不同环境下也能被正确执行. 以下函数兼容Surge、QX、Loon中的部分API, 包括持久化读取、通知、POST请求 兼容函数 (点击左边箭头展开) >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// const $ = new nobyda(); // 发送一个通知: $.notify('title', 'subtitle', 'message')// 持久化读取: $.read('Key')// POST请求: $.post(url&lt;Object&gt;,callback&lt;Function&gt;)function nobyda() { const isSurge = typeof $httpClient != &quot;undefined&quot;; const isQuanX = typeof $task != &quot;undefined&quot;; const isNode = typeof require == &quot;function&quot;; const node = (() =&gt; { if (isNode) { const request = require('request'); return { request } } else { return null; } })() const adapterStatus = (response) =&gt; { if (response) { if (response.status) { response[&quot;statusCode&quot;] = response.status } else if (response.statusCode) { response[&quot;status&quot;] = response.statusCode } } return response } this.read = (key) =&gt; { if (isQuanX) return $prefs.valueForKey(key) if (isSurge) return $persistentStore.read(key) } this.notify = (title, subtitle, message) =&gt; { if (isQuanX) $notify(title, subtitle, message) if (isSurge) $notification.post(title, subtitle, message) if (isNode) console.log(`${title}\\n${subtitle}\\n${message}`) } this.post = (options, callback) =&gt; { options.headers['User-Agent'] = 'User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 13_6_1 like Mac OS X) AppleWebKit/609.3.5.0.2 (KHTML, like Gecko) Mobile/17G80 BiliApp/822 mobi_app/ios_comic channel/AppStore BiliComic/822' if (isQuanX) { if (typeof options == &quot;string&quot;) options = { url: options } options[&quot;method&quot;] = &quot;POST&quot; $task.fetch(options).then(response =&gt; { callback(null, adapterStatus(response), response.body) }, reason =&gt; callback(reason.error, null, null)) } if (isSurge) { options.headers['X-Surge-Skip-Scripting'] = false $httpClient.post(options, (error, response, body) =&gt; { callback(error, adapterStatus(response), body) }) } if (isNode) { node.request.post(options, (error, response, body) =&gt; { callback(error, adapterStatus(response), body) }) } } this.done = () =&gt; { if (isQuanX || isSurge) { $done() } }}; 全局变量写好兼容函数后我们先定义一些全局变量, 供所有函数调用. 全局变量1234567891011121314151617// 新建一个实例对象, 把兼容函数定义到$中, 以便统一调用let $ = new nobyda();// 读取兑换商品名, 默认兑换积分商城中的&quot;积分兑换&quot;; 该接口为BoxJs预留, 以便修改let productName = $.read('BM_ProductName') || '积分兑换';// 读取兑换数量, 默认兑换最大值; 该接口为BoxJs预留, 以便修改let productNum = $.read('BM_ProductNum');// 读取循环抢购次数, 默认100次; 该接口为BoxJs预留, 以便修改let exchangeNum = $.read('BM_ExchangeNum') || '100';// 读取哔哩哔哩漫画签到脚本所使用的Cookielet cookie = $.read('CookieBM');// 预留的空对象, 便于函数之间读取数据let user = {}; 查询积分脚本开始时首先要做的是查询账号里的积分是否符合兑换要求. 该函数调用时, 将执行查询积分, 如果查询用户积分成功, 则将查询到的积分赋值到全局变量中, 供其他函数读取. 查询积分函数1234567891011121314151617181920212223242526272829function GetUserPoint() { const pointUrl = { //查询积分接口 url: 'https://manga.bilibili.com/twirp/pointshop.v1.Pointshop/GetUserPoint', headers: { //请求头 'Cookie': cookie //用户鉴权Cookie } } return new Promise((resolve) =&gt; { //主函数返回Promise实例对象, 以便后续调用时可以实现顺序执行异步函数 $.post(pointUrl, (error, resp, data) =&gt; { //使用post请求查询, 再使用回调函数处理返回的结果 try { //使用try方法捕获可能出现的代码异常 if (error) { throw new Error(error); //如果请求失败, 例如无法联网, 则抛出一个异常 } else { const body = JSON.parse(data); //解析响应体json并转化为对象 if (body.code == 0 &amp;&amp; body.data) { //如果响应体为预期格式 user.point = parseInt(body.data.point); //把查询的积分赋值到全局变量user中 console.log(`\\n当前积分: ${body.data.point}`); //打印日志 } else { //否则抛出一个异常 throw new Error(body.msg || data); } } } catch (e) { //接住try代码块中抛出的异常, 并打印日志 console.log(`\\n查询积分: 失败\\n出现错误: ${e.message}`); } finally { //finally语句在try和catch之后无论有无异常都会执行 resolve(); //异步操作成功时调用, 将Promise对象的状态标记为&quot;成功&quot;, 表示已完成查询积分 } }) })} 查询商品根据前面的分析, 我们兑换商品时需要相应的商品ID. 该函数调用时, 将执行查询操作, 并根据全局变量所定义的商品名进行过滤, 过滤后的内容仅包含相关商品的基本信息, 例如商品ID、兑换价格、库存等, 再把过滤后的内容赋值到全局变量中, 供其他函数读取. 查询商品函数1234567891011121314151617181920212223242526272829303132function ListProduct() { const listUrl = { //查询商品接口 url: 'https://manga.bilibili.com/twirp/pointshop.v1.Pointshop/ListProduct', headers: {} } return new Promise((resolve) =&gt; { //主函数返回Promise实例对象, 以便后续调用时可以实现顺序执行异步函数 $.post(listUrl, (error, resp, data) =&gt; { //使用post请求查询, 再使用回调函数处理返回的结果 try { //使用try方法捕获可能出现的代码异常 if (error) { throw new Error(error); //如果请求失败, 例如无法联网, 则抛出一个异常 } else { const body = JSON.parse(data); //解析响应体json并转化为对象 if (body.code == 0 &amp;&amp; body.data.length &gt;= 1) { //如果接口正常返回商品信息 // 按全局变量所填写的商品名进行过滤, 并把商品信息赋值到全局变量user中 user.list = body.data.filter(t =&gt; t.title == productName).pop(); if (!user.list) { throw new Error('请检查商品名'); //如果填错商品名则抛出一个异常 } else { //否则打印日志 console.log(`\\n查询商品: ${productName}\\n商品库存: ${user.list.remain_amount}`) } } else { //否则抛出一个异常 throw new Error('无商品列表'); } } } catch (e) { //接住try代码块中抛出的异常并打印日志 console.log(`\\n查询商品: ${productName}\\n出现错误: ${e.message}`); } finally { //finally语句在try和catch之后无论有无异常都会执行 resolve(); //异步操作成功时调用, 将Promise对象的状态标记为&quot;成功&quot;, 表示已完成查询商品 } }) })} 兑换商品兑换商品分为两个函数, 第一个函数调用后, 将根据前面查询到的数据进行判断, 如果商品有库存并且用户积分大于100, 则根据全局变量所定义的循环次数, 暴力调用第二个”请求”函数 (默认循环100次) 兑换商品函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function ExchangeProduct() { return new Promise(async (resolve) =&gt; { //主函数返回Promise实例对象, 以便后续调用时可以实现顺序执行异步函数, 该实例函数带有async关键字, 表示里面有异步操作, 例如可使用await得到异步结果 if (user.list &amp;&amp; user.list.remain_amount &amp;&amp; user.point &gt;= 100) { //如果商品有库存并且用户积分大于100则进行抢购 //兑换商品数量(用户积分 除与 商品单价得到兑换数量), 并转成整数; 默认兑换最大数量 const num = parseInt(productNum || (user.point / user.list.real_cost)); const exchangeUrl = { url: 'https://manga.bilibili.com/twirp/pointshop.v1.Pointshop/Exchange', //兑换商品接口 headers: { //请求头 'Content-Type': 'application/json', //声明请求体数据格式 'Cookie': cookie //用户鉴权Cookie }, body: JSON.stringify({ //请求体转成字符串类型 product_id: user.list.id, //兑换的商品id product_num: num, //兑换的商品数量 point: num * user.list.real_cost //消耗的积分总数 (兑换数量乘单价得到积分总数) }) }; for (let i = 0; i &lt; parseInt(exchangeNum); i++) { //根据全局变量定义的次数, 暴力循环抢购 // 循环内调用另一个抢购函数, 并传入请求、第几次循环、兑换数量等参数, // 使用await关键字声明, 表示需要等待每一次的执行结果 const run = await startExchange(exchangeUrl, i, num); if (run) { break; //如果函数返回布尔值true, 则跳出循环, 脚本结束 } } } else { //商品无库存或用户积分小于100等情况, 则不执行抢购, 脚本结束 console.log(`\\n抢购终止: 不具备兑换条件`); //打印日志 } resolve(); //将主函数的Promise对象状态标记为&quot;成功&quot;, 表示已完成抢购任务 })}function startExchange(url, item, amount) { return new Promise((resolve) =&gt; { //主函数返回Promise实例对象, 以便后续调用时可以实现顺序执行异步函数 $.post(url, (error, resp, data) =&gt; { //使用post请求查询, 再使用回调函数处理返回的结果 try { //使用try方法捕获可能出现的代码异常 if (error) { throw new Error(error); //如果请求失败, 例如无法联网, 则抛出一个异常 } else { const body = JSON.parse(data); //解析响应体json并转化为对象 if (body.code == 0) { //如果抢购成功, 则输出日志和通知 console.log(`\\n抢购成功: 第${item+1}次\\n抢购数量: ${amount}\\n消耗积分: ${amount * user.list.real_cost}`); $.notify('哔哩哔哩漫画抢券', '', `&quot;${productName}&quot;抢购成功, 数量: ${amount}, 消耗积分: ${amount * user.list.real_cost}`); resolve(true); //将Promise对象的状态标记为&quot;成功&quot;, 然后返回一个布尔值true用于跳出循环 } else { throw new Error(body.msg || '未知'); //抢购失败则抛出异常 } } } catch (e) { //接住try代码块中抛出的异常并打印日志 console.log(`\\n抢购失败: 第${item+1}次\\n失败原因: ${e.message}`); resolve(); //将Promise对象的状态标记为&quot;成功&quot;, 但不返回任何值, 表示继续循环抢购 } }) })} 统一调用写好函数后, 如果不进行调用, 那么代码是无法被运行的. 在javascript中, 代码的执行顺序很重要, 我们的需求是先同时查询积分和商品, 再抢购, 最后退出脚本. 以下匿名函数将按我们预期的顺序执行. 匿名异步函数123456789(async function() { // 立即运行的匿名异步函数 // 使用await关键字声明, 表示以同步方式执行异步函数, 可以简单理解为顺序执行 await Promise.all([ //该方法用于将多个实例包装成一个新的实例, 可以简单理解为同时调用函数, 以进一步提高执行速度 GetUserPoint(), //查询积分函数 ListProduct() //查询商品函数 ]); await ExchangeProduct(); //上面的查询都完成后, 则执行抢购 $.done(); //抢购完成后调用Surge、QX内部特有的函数, 用于退出脚本执行})(); 第四步: 配置任务我们写好脚本后, 就可以在Surge或QuantumultX里配置定时任务让它在规定时间内执行该脚本. 以下将用Surge进行演示 编辑Surge配置文件, 在[Script]段落放入以下脚本 1哔哩哔哩漫画抢券 = type=cron,cronexp=&quot;10,20,30 0 12 * * *&quot;,wake-system=1,timeout=60,script-path=https://raw.githubusercontent.com/NobyDa/Script/master/Bilibili-DailyBonus/ExchangePoints.js 因为积分商城刷新时间在每天中午12点, 则以上配置将在每天中午12:00:10、12:00:20、12:00:30分别执行一次. 有几点需要注意 脚本抢购完成后注意禁用, 避免每天无意义的运行 脚本需要使用哔哩哔哩签到脚本获取Cookie后方可使用. 默认兑换积分商城中的 “积分兑换”; 可自行修改. 兑换数量为用户积分可兑换的最大值; 可自行修改. 结语本文又是一篇专业性极强的文章, 有的同学可能又要头大了; 写这篇文章动机主要是为了让读者了解一个需求的实现过程, 脚本里也有大量注释供读者理解思路. 这个需求说难也不太难, 就是抓几个接口去模拟用户兑换的行为. 当然还是需要有一定的抓包经验和javascript功底才行; 我的javascript功底也就勉勉强强够我写几个简单需求. 虽然本文看起来比较水, 但还是建议初学者照着本文去理解抓包思路, 以及脚本的执行逻辑. 最后, 提前祝大家周末愉快!","link":"/2021/07/16/BilibiliManga_Js_example/"},{"title":"适用于Surge &amp; QuantumultX的一次性密码生成脚本 (TOTP)","text":"TOTP全称为 “基于时间的一次性密码”，又称两步验证、双因素认证； 本文将简单介绍如何在Surge或QuantumultX等原生JavaScript环境里实现获取TOTP 6位数一次性密码。 一次性密码也称为动态口令，通常用在web应用或者其他登录系统中，是增强静态密码的一种非常方便的技术手段。 原理TOTP的基本认证原理简单概括： 客户端/服务端使用密码技术生成密钥后双方共享该密钥，之后需要验证时使用同一个密钥对当前时间进行密码算法计算，再比较计算值是否一致进行认证； 计算后生成的动态口令通常30秒失效，口令长度通常为6位数字；认证时的唯一要求是客户端和服务端能够十分精确的保持正确的时钟，客户端和服务端计算的动态口令才能一致。 实现因为上一篇文章所演示的 “巴哈姆特签到脚本” 中，部分用户反映如果账号设置两步验证后脚本将无法登录； 所以抽时间适配了一个支持在任何Javascript环境中都可用的TOTP算法函数。 该函数已开源，项目地址：Time-based-One-Time-Password 示例TOTP.min.js123456const key = 'YOURCLIENTTOKEN'; //TOTP密钥const totp = TOTP(key); //返回六位数一次性口令。console.log(totp); //打印日志function TOTP(token){function t(e,a,d){var g=0,c=[],b=0,f,k,l,h,m,w,n,y,p=!1,q=[],t=[],v,u=!1;d=d||{};f=d.encoding||&quot;UTF8&quot;;v=d.numRounds||1;l=z(a,f);if(v!==parseInt(v,10)||1&gt;v)throw Error(&quot;numRounds must a integer &gt;= 1&quot;);if(&quot;SHA-1&quot;===e)m=512,w=A,n=H,h=160,y=function(a){return a.slice()};else throw Error(&quot;Chosen SHA variant is not supported&quot;);k=x(e);this.setHMACKey=function(a,b,c){var d;if(!0===p)throw Error(&quot;HMAC key already set&quot;);if(!0===u)throw Error(&quot;Cannot set HMAC key after calling update&quot;);f=(c||{}).encoding||&quot;UTF8&quot;;b=z(b,f)(a);a=b.binLen;b=b.value;d=m&gt;&gt;&gt;3;c=d/4-1;if(d&lt;a/8){for(b=n(b,a,0,x(e),h);b.length&lt;=c;)b.push(0);b[c]&amp;=4294967040}else if(d&gt;a/8){for(;b.length&lt;=c;)b.push(0);b[c]&amp;=4294967040}for(a=0;a&lt;=c;a+=1)q[a]=b[a]^909522486,t[a]=b[a]^1549556828;k=w(q,k);g=m;p=!0};this.update=function(a){var d,e,f,h=0,n=m&gt;&gt;&gt;5;d=l(a,c,b);a=d.binLen;e=d.value;d=a&gt;&gt;&gt;5;for(f=0;f&lt;d;f+=n)h+m&lt;=a&amp;&amp;(k=w(e.slice(f,f+n),k),h+=m);g+=h;c=e.slice(h&gt;&gt;&gt;5);b=a%m;u=!0};this.getHash=function(a,d){var f,l,m,r;if(!0===p)throw Error(&quot;Cannot call getHash after setting HMAC key&quot;);m=B(d);switch(a){case&quot;HEX&quot;:f=function(a){return C(a,h,m)};break;case&quot;B64&quot;:f=function(a){return D(a,h,m)};break;case&quot;BYTES&quot;:f=function(a){return E(a,h)};break;case&quot;ARRAYBUFFER&quot;:try{l=new ArrayBuffer(0)}catch(I){throw Error(&quot;ARRAYBUFFER not supported by this environment&quot;);}f=function(a){return F(a,h)};break;default:throw Error(&quot;format must be HEX, B64, BYTES, or ARRAYBUFFER&quot;);}r=n(c.slice(),b,g,y(k),h);for(l=1;l&lt;v;l+=1)r=n(r,h,0,x(e),h);return f(r)};this.getHMAC=function(a,d){var f,l,q,r;if(!1===p)throw Error(&quot;Cannot call getHMAC without first setting HMAC key&quot;);q=B(d);switch(a){case&quot;HEX&quot;:f=function(a){return C(a,h,q)};break;case&quot;B64&quot;:f=function(a){return D(a,h,q)};break;case&quot;BYTES&quot;:f=function(a){return E(a,h)};break;case&quot;ARRAYBUFFER&quot;:try{f=new ArrayBuffer(0)}catch(I){throw Error(&quot;ARRAYBUFFER not supported by this environment&quot;);}f=function(a){return F(a,h)};break;default:throw Error(&quot;outputFormat must be HEX, B64, BYTES, or ARRAYBUFFER&quot;);}l=n(c.slice(),b,g,y(k),h);r=w(t,x(e));r=n(l,h,m,r,h);return f(r)}}function J(e,a,d){var g=e.length,c,b,f,k,l;a=a||[0];d=d||0;l=d&gt;&gt;&gt;3;if(0!==g%2)throw Error(&quot;String of HEX type must be in byte increments&quot;);for(c=0;c&lt;g;c+=2){b=parseInt(e.substr(c,2),16);if(isNaN(b))throw Error(&quot;String of HEX type contains invalid characters&quot;);k=(c&gt;&gt;&gt;1)+l;for(f=k&gt;&gt;&gt;2;a.length&lt;=f;)a.push(0);a[f]|=b&lt;&lt;8*(3-k%4)}return{value:a,binLen:4*g+d}}function K(e,a,d){var g=[],c,b,f,k,g=a||[0];d=d||0;b=d&gt;&gt;&gt;3;for(c=0;c&lt;e.length;c+=1)a=e.charCodeAt(c),k=c+b,f=k&gt;&gt;&gt;2,g.length&lt;=f&amp;&amp;g.push(0),g[f]|=a&lt;&lt;8*(3-k%4);return{value:g,binLen:8*e.length+d}}function L(e,a,d){var g=[],c=0,b,f,k,l,h,m,g=a||[0];d=d||0;a=d&gt;&gt;&gt;3;if(-1===e.search(/^[a-zA-Z0-9=+\\/]+$/))throw Error(&quot;Invalid character in base-64 string&quot;);f=e.indexOf(&quot;=&quot;);e=e.replace(/\\=/g,&quot;&quot;);if(-1!==f&amp;&amp;f&lt;e.length)throw Error(&quot;Invalid '=' found in base-64 string&quot;);for(f=0;f&lt;e.length;f+=4){h=e.substr(f,4);for(k=l=0;k&lt;h.length;k+=1)b=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;.indexOf(h[k]),l|=b&lt;&lt;18-6*k;for(k=0;k&lt;h.length-1;k+=1){m=c+a;for(b=m&gt;&gt;&gt;2;g.length&lt;=b;)g.push(0);g[b]|=(l&gt;&gt;&gt;16-8*k&amp;255)&lt;&lt;8*(3-m%4);c+=1}}return{value:g,binLen:8*c+d}}function M(e,a,d){var g=[],c,b,f,g=a||[0];d=d||0;c=d&gt;&gt;&gt;3;for(a=0;a&lt;e.byteLength;a+=1)f=a+c,b=f&gt;&gt;&gt;2,g.length&lt;=b&amp;&amp;g.push(0),g[b]|=e[a]&lt;&lt;8*(3-f%4);return{value:g,binLen:8*e.byteLength+d}}function C(e,a,d){var g=&quot;&quot;;a/=8;var c,b;for(c=0;c&lt;a;c+=1)b=e[c&gt;&gt;&gt;2]&gt;&gt;&gt;8*(3-c%4),g+=&quot;0123456789abcdef&quot;.charAt(b&gt;&gt;&gt;4&amp;15)+&quot;0123456789abcdef&quot;.charAt(b&amp;15);return d.outputUpper?g.toUpperCase():g}function D(e,a,d){var g=&quot;&quot;,c=a/8,b,f,k;for(b=0;b&lt;c;b+=3)for(f=b+1&lt;c?e[b+1&gt;&gt;&gt;2]:0,k=b+2&lt;c?e[b+2&gt;&gt;&gt;2]:0,k=(e[b&gt;&gt;&gt;2]&gt;&gt;&gt;8*(3-b%4)&amp;255)&lt;&lt;16|(f&gt;&gt;&gt;8*(3-(b+1)%4)&amp;255)&lt;&lt;8|k&gt;&gt;&gt;8*(3-(b+2)%4)&amp;255,f=0;4&gt;f;f+=1)8*b+6*f&lt;=a?g+=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;.charAt(k&gt;&gt;&gt;6*(3-f)&amp;63):g+=d.b64Pad;return g}function E(e,a){var d=&quot;&quot;,g=a/8,c,b;for(c=0;c&lt;g;c+=1)b=e[c&gt;&gt;&gt;2]&gt;&gt;&gt;8*(3-c%4)&amp;255,d+=String.fromCharCode(b);return d}function F(e,a){var d=a/8,g,c=new ArrayBuffer(d);for(g=0;g&lt;d;g+=1)c[g]=e[g&gt;&gt;&gt;2]&gt;&gt;&gt;8*(3-g%4)&amp;255;return c}function B(e){var a={outputUpper:!1,b64Pad:&quot;=&quot;,shakeLen:-1};e=e||{};a.outputUpper=e.outputUpper||!1;!0===e.hasOwnProperty(&quot;b64Pad&quot;)&amp;&amp;(a.b64Pad=e.b64Pad);if(&quot;boolean&quot;!==typeof a.outputUpper)throw Error(&quot;Invalid outputUpper formatting option&quot;);if(&quot;string&quot;!==typeof a.b64Pad)throw Error(&quot;Invalid b64Pad formatting option&quot;);return a}function z(e,a){var d;switch(a){case&quot;UTF8&quot;:case&quot;UTF16BE&quot;:case&quot;UTF16LE&quot;:break;default:throw Error(&quot;encoding must be UTF8, UTF16BE, or UTF16LE&quot;);}switch(e){case&quot;HEX&quot;:d=J;break;case&quot;TEXT&quot;:d=function(d,c,b){var f=[],e=[],l=0,h,m,q,n,p,f=c||[0];c=b||0;q=c&gt;&gt;&gt;3;if(&quot;UTF8&quot;===a)for(h=0;h&lt;d.length;h+=1)for(b=d.charCodeAt(h),e=[],128&gt;b?e.push(b):2048&gt;b?(e.push(192|b&gt;&gt;&gt;6),e.push(128|b&amp;63)):55296&gt;b||57344&lt;=b?e.push(224|b&gt;&gt;&gt;12,128|b&gt;&gt;&gt;6&amp;63,128|b&amp;63):(h+=1,b=65536+((b&amp;1023)&lt;&lt;10|d.charCodeAt(h)&amp;1023),e.push(240|b&gt;&gt;&gt;18,128|b&gt;&gt;&gt;12&amp;63,128|b&gt;&gt;&gt;6&amp;63,128|b&amp;63)),m=0;m&lt;e.length;m+=1){p=l+q;for(n=p&gt;&gt;&gt;2;f.length&lt;=n;)f.push(0);f[n]|=e[m]&lt;&lt;8*(3-p%4);l+=1}else if(&quot;UTF16BE&quot;===a||&quot;UTF16LE&quot;===a)for(h=0;h&lt;d.length;h+=1){b=d.charCodeAt(h);&quot;UTF16LE&quot;===a&amp;&amp;(m=b&amp;255,b=m&lt;&lt;8|b&gt;&gt;&gt;8);p=l+q;for(n=p&gt;&gt;&gt;2;f.length&lt;=n;)f.push(0);f[n]|=b&lt;&lt;8*(2-p%4);l+=2}return{value:f,binLen:8*l+c}};break;case&quot;B64&quot;:d=L;break;case&quot;BYTES&quot;:d=K;break;case&quot;ARRAYBUFFER&quot;:try{d=new ArrayBuffer(0)}catch(g){throw Error(&quot;ARRAYBUFFER not supported by this environment&quot;);}d=M;break;default:throw Error(&quot;format must be HEX, TEXT, B64, BYTES, or ARRAYBUFFER&quot;);}return d}function p(e,a){return e&lt;&lt;a|e&gt;&gt;&gt;32-a}function q(e,a){var d=(e&amp;65535)+(a&amp;65535);return((e&gt;&gt;&gt;16)+(a&gt;&gt;&gt;16)+(d&gt;&gt;&gt;16)&amp;65535)&lt;&lt;16|d&amp;65535}function u(e,a,d,g,c){var b=(e&amp;65535)+(a&amp;65535)+(d&amp;65535)+(g&amp;65535)+(c&amp;65535);return((e&gt;&gt;&gt;16)+(a&gt;&gt;&gt;16)+(d&gt;&gt;&gt;16)+(g&gt;&gt;&gt;16)+(c&gt;&gt;&gt;16)+(b&gt;&gt;&gt;16)&amp;65535)&lt;&lt;16|b&amp;65535}function x(e){var a=[];if(&quot;SHA-1&quot;===e)a=[1732584193,4023233417,2562383102,271733878,3285377520];else throw Error(&quot;No SHA variants supported&quot;);return a}function A(e,a){var d=[],g,c,b,f,k,l,h;g=a[0];c=a[1];b=a[2];f=a[3];k=a[4];for(h=0;80&gt;h;h+=1)d[h]=16&gt;h?e[h]:p(d[h-3]^d[h-8]^d[h-14]^d[h-16],1),l=20&gt;h?u(p(g,5),c&amp;b^~c&amp;f,k,1518500249,d[h]):40&gt;h?u(p(g,5),c^b^f,k,1859775393,d[h]):60&gt;h?u(p(g,5),c&amp;b^c&amp;f^b&amp;f,k,2400959708,d[h]):u(p(g,5),c^b^f,k,3395469782,d[h]),k=f,f=b,b=p(c,30),c=g,g=l;a[0]=q(g,a[0]);a[1]=q(c,a[1]);a[2]=q(b,a[2]);a[3]=q(f,a[3]);a[4]=q(k,a[4]);return a}function H(e,a,d,g){var c;for(c=(a+65&gt;&gt;&gt;9&lt;&lt;4)+15;e.length&lt;=c;)e.push(0);e[a&gt;&gt;&gt;5]|=128&lt;&lt;24-a%32;a+=d;e[c]=a&amp;4294967295;e[c-1]=a/4294967296|0;a=e.length;for(c=0;c&lt;a;c+=16)g=A(e.slice(c,c+16),g);return g}function X(y){return(y&lt;15.5?'0':'')+Math.round(y).toString(16)}function V(b){var s=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;;var t=&quot;&quot;;var h=&quot;&quot;;for(var i=0;i&lt;b.length;i++){var val=s.indexOf(b.charAt(i).toUpperCase());t+=T(val.toString(2),5,'0')}for(var i=0;i+4&lt;=t.length;i+=4){var c=t.substr(i,4);h=h+parseInt(c,2).toString(16)}return h}function T(s,l,p){if(l+1&gt;=s.length){s=Array(l+1-s.length).join(p)+s}return s}return(function(s){var k=V(s);var e=Math.round(new Date().getTime()/1000.0);var r=T(X(Math.floor(e/30)),16,'0');var j=new t(&quot;SHA-1&quot;,&quot;HEX&quot;);j.setHMACKey(k,&quot;HEX&quot;);j.update(r);var h=j.getHMAC(&quot;HEX&quot;);var o=parseInt(h.substring(h.length-1),16);var p=(parseInt(h.substr(o*2,8),16)&amp;parseInt('7fffffff',16))+'';var z=p.substr(p.length-6,6);return z})(token)}; TOTP函数生成的一次性密码遵循RFC6238规范，完全使用原生Javascript实现，可在任何Javascript环境中使用 (不依赖任何框架和类库)。 致谢该函数魔改至 https://jsfiddle.net/russau/rbyjk774 并使用了Brian Turek的jsSHA，在此表示感谢。","link":"/2021/07/29/Javascript-TOTP-algorithm/"},{"title":"使用Surge规则脚本、快捷指令自动化生成专属规则集","text":"本文为Surge APP规则系统中的高级使用方法，有一定的理解难度。 不知道大家有没有想过，Github 上大佬们分享的大多都是通用规则集，并不一定适合自己，所以有时候就在想，除了特定应用程序的规则，国内域名和国外域名能不能按照自己的网络环境自动生成一份专属规则。 思路我们可以使用 Surge 的脚本规则实现，由于 Surge 本身无法写入文件到本地，但我们可以借助系统的自带的快捷指令写入，所以我们基本的实现思路大致为： 域名请求命中脚本规则 脚本规则缓存加工后的域名 快捷指令读取脚本规则缓存并写入规则集到本地 脚本实现该脚本已上传至 Github 仓库，链接： 1https://github.com/NobyDa/Script/blob/master/Rule-Storage/Rule-Storage.js 工作流简化后的脚本核心工作流： 为了避免生成太多无用规则，脚本会判断多级域名并有相应的处理。eTLD 即公共后缀列表，指的是Internet域名系统中的一部分域名，这部分域名在 eTLD 列表中定义。例如一个域名 www.abc.com，eTLD 列表内将包含 com 这个顶级域。 脚本规则可以参照该 eTLD 列表缩减多级域名并生成域名后缀规则（DOMAIN-SUFFIX），但二级域名、非 eTLD 域名、完整 eTLD 域名只会生成域名规则（DOMAIN） 配置脚本配置我的需求是生成国内域名和国外域名的规则集，我们首先配置 Surge 脚本，在 Surge 配置文件中的[Script]段落添加以下脚本，参数可以按照说明按需添加 123Save-Final-Rule = type=rule,script-path=https://raw.githubusercontent.com/NobyDa/Script/master/Rule-Storage/Rule-Storage.js,argument=region=globalSave-China-Rule = type=rule,script-path=https://raw.githubusercontent.com/NobyDa/Script/master/Rule-Storage/Rule-Storage.js,argument=region=china&amp;matched=1 参数由于脚本设计之初考虑到脚本复用问题，我们需要配置参数才能正确运行 区域参数：region，该参数为必须 匹配参数：matched，即指示脚本规则完成后是否匹配指定的策略，默认不匹配，输入matched=1即表示匹配 键值参数：key，持久化储存所使用的键值，默认为Rule-Storage，一般用户无需理会 白名单参数：whitelist，域名匹配白名单规则时，跳过生成域名后缀规则（DOMAIN-SUFFIX），该参数仅接受数组，例如whitelist=[&quot;.mwcname.com&quot;,&quot;.cdn.&quot;]，规则有三种写法： 域名：example.com 域名后缀：.example.com 域名关键字：.example. 数量参数：quantity，一个域名运行脚本第x次才生成规则，默认为 10 次 间隔参数：interval，一个域名两次运行脚本的标记间隔，默认为 30 秒 除了区域参数为必要之外，其他参数都有默认值，需要注意的是脚本内已内置了部分跳过生成域名后缀的白名单规则，如果白名单参数存在，将会被参数覆盖。 多参数使用 &amp; 连接，例如： 1argument=region=global&amp;quantity=5&amp;interval=10 配置规则配置要生成国内和国外规则，那么这个脚本规则必须放在FINAL规则前，规则的先后顺序非常重要，由于每个人使用的规则都有细微差别，所以这里我们展开讲讲。 规则示例： 配置示例： 12345RULE-SET,Rule/Foregn_Set.txt,🌎 Foregn,no-resolve,extended-matchingRULE-SET,Rule/Domestic_Set.txt,🇨🇳 Domestic,extended-matchingAND,((OR,((GEOIP,CN), (DOMAIN-SUFFIX,cn), (AND,((RULE-SET,https://raw.githubusercontent.com/NobyDa/Script/master/Rule-Storage/Include-Domain.txt), (SCRIPT,Save-Final-Rule))))), (OR,((NOT,((RULE-SET,https://raw.githubusercontent.com/NobyDa/Script/master/Rule-Storage/Include-Domain.txt))), (SCRIPT,Save-China-Rule)))),🇨🇳 Domestic 其中 Foregn_Set.txt 和 Domestic_Set.txt 为快捷指令读取脚本规则缓存生成的本地规则集文件，稍后我们会讲到。规则顺序为 国内规则集（生成） 国外规则集（生成） 逻辑规则，内含脚本规则 Surge 的规则系统在前面的规则匹配后，后面的规则将不会执行，所以我们以这个为基础写一个逻辑规则 工作流以下为配置示例中的逻辑规则工作流： 为了性能考虑避免IP域名经过脚本，以及实现区域判定，我们需要借助 GeoIP 规则、域名关键字规则、逻辑规则互相配合才能完成。 逻辑规则中的子规则可以按需修改，比如去掉DOMAIN-SUFFIX,cn规则。逻辑规则基本概念可以在 Surge 文档中找到 GEOIP因为区域判断是基于GEOIP数据库，所以我们需要一份相对准确的数据库，这里推荐使用自己另外一个项目，自用了几年还不错。仓库地址： 1https://github.com/NobyDa/geoip 配置快捷指令域名经过逻辑规则和脚本生成缓存规则后，我们可以写一个快捷指令提取 Surge 中的缓存规则并写入文件到本地。 我们需要先配置 Surge 中自带的 HTTP API 功能，可以在Surge -&gt; 更多设置 -&gt; HTTP API中找到，设置端口和密码后，在安装快捷指令时填入即可。 快捷指令安装链接： 1https://www.icloud.com/shortcuts/39c9a8720c9a49288ac1a2bf433da098 需要注意的是，如果没有开启 Surge iCloud 同步将无法使用（生成的规则集储存在 iCloud 的 Surge 文件夹） 快捷指令默认会把 Foregn_Set.txt 和 Domestic_Set.txt 规则集储存至 Surge 根目录的 Rule 文件夹，可以手动编辑快捷指令修改 China &amp; Global词典。 词典内的Key即为 Surge 持久化规则缓存的读取键值（脚本内会根据脚本参数的键值参数和区域参数自动拼接读取键值，自用的是Rule-Storage-china和Rule-Storage-global）一般无需修改。 自动化生成规则后我们可以使用快捷指令的自动化自动运行快捷指令，例如可以每天特定时间或打开 Surge 时运行快捷指令，这类自动化都可以关闭运行前询问。按自己的需求设置即可。 事项这个脚本的初衷是为了解决规则系统的 DNS 查询问题，经常访问的国外域名可以在 FINAL 规则之前省去一次 DNS 查询以获得更好的体验，脚本经过多次迭代后基本已经没有太大问题。 如果有小伙伴需要使用文章中的脚本规则，请务必注意调整自己所使用的通用规则，例如配置生成的规则后需要删除之前所使用的通用 China 或 Global 规则集，也需要禁用IP类规则集，最主要的是规则顺序，一些细节问题也要根据实际情况进行调整。所以只建议对 Surge 和规则有一定理解、动手能力强的小伙伴去折腾。 问题 由于是自动生成的规则，有时候需要手动调整生成后的规则，例如删除一些不需要被代理的域名。 由于国外规则集顺序在前，有时候会混进一些国内域名导致分流不符合预期，这里可以使用另外一个快捷指令移除国外规则集里跟国内规则集重复的规则。 1https://www.icloud.com/shortcuts/cf7e329cf84147ad90447cc7135b53e0 由于刚开始需要使用一段后才会生成规则，如果确认要使用，推荐短期内调整一下脚本参数的数量参数和间隔参数 以达到快速生成规则的目的。 后记说起来也好久没有更新博客和脚本了，一方面是因为装源码的硬盘出了点小问题，索性就放抽屉吃灰了，另一方面也可能是自己对这类APP痛失了兴趣，没有足够的动力对开源社区做出贡献。 事情起因可能是因为有一天突然意识到赞许的声音越来越多，以致于自己在网络上花的时间日益增多，进而疏忽了现实生活中的一些人和事。这引起了我对当下生活的一种深度思考。 人嘛，总是会选择一种生活方式来构建自己生活的意义，每个年龄段的意义都会不尽相同。美好生活就是让自己过上喜欢的日子，这是我对美好生活的定义。这鼓励了我，所以我开始减少花在网络上的时间，给生活做减法。 时间果然转瞬即逝，到了2024又是一个新的篇章，也挺久没有折腾 Surge 脚本了，为此分享给大家一个自用脚本。由于是按照自己需求写的所以不一定适合大众，有类似需求的小伙伴可以参考文章的思路的手动配置专属规则。 生命不息，折腾不止。 以上","link":"/2024/02/24/Surge_Rule_Storage/"},{"title":"使用Surge脚本 &amp; 逻辑规则建立联网防火墙","text":"前言 本文仅建议对Surge(iOS) APP有一定熟悉的用户阅读. 如您从未使用过, 则该文可能不适合您. 本文主要内容为 “手机APP(iOS) 隐私泄漏” 问题以及解决方案. 本文将会耗费大量篇幅讲解Surge脚本或Surge逻辑规则的运用、科普、 实现、以及原理, 并建立手机网络防火墙. 背景有一个话题引起了我的关注, 一些国内APP (iOS), 如: X信, XX宝, X团. 用户安装以上APP后, 手机从蜂窝网络切换至WiFi的一瞬间(包括自动连接), 以上APP可能会利用iOS某个系统接口直接后台唤醒, 并向服务器上传网络请求, 经过抓包后发现, 该类请求都隶属于以上APP (查询ASN得知), 并且都经过强加密, 无法得知上传内容. 以上情况不管用户是否关闭后台或关闭后台刷新, 都有可能会触发. 如果用户手动打开系统设置查看WiFi列表, 也可能会触发以上APP的某些联网请求. 该类网络请求可能会上传: WiFi名称 (SSID) 定位数据 接入或断开WiFi的时间 以上基于常识推断; 由于笔者非iOS开发者, 无法得知APP在该情况下具有的权限, 不对的还请指正. 企业对该数据可能会: 出售或共享, 建立大数据 推断出你的作息规律, 几点几分离开家/到公司, 并建立用户画像 基于以上两点精准推送广告 以上为背景介绍 应对 借助Surge强大的脚本和规则系统, 目前有两种解决方案 方案一概括APP关闭时(后台), 完全拦截手机所有APP联网请求; APP开启时(前台), 放行所有APP联网请求. (只允许用户主动开启APP表示我需要用到它,否则不允许乱联网) 方案二概括手机从蜂窝网络切换至WiFi(手动/自动)的瞬间, 15秒内拦截所有APP联网请求(前台/后台), 15秒后恢复 该方案提供懒人Surge模块一键配置, 具体可查看本文实现方案二章节 为了使读者更好的理解, 本文将会极其详细的描述以上两种方案里每一步的原理以及配置, 供读者参考. 实现方案一需求: 打开手机内任何一个APP时(前台), 放行网络请求 关闭任何一个APP时(后台), 拦截所有请求 拦截的请求可以设置白名单 有两种思路: 捷径自动化触发, 当打开/关闭APP时, 运行捷径, 捷径内容为调用SurgeAPI(开启/关闭)模块, 模块内容为: 拒绝所有网络请求和白名单在内的规则 捷径自动化触发, 当打开/关闭APP时, 运行捷径, 捷径内容为运行Surge脚本, 脚本内容为: 储存当前APP状态(打开/关闭), 再使用Surge逻辑规则和脚本规则共同决定网络请求是否需要拦截 由于Surge模块的特殊性, 开启/关闭模块时, 会导致: 触发重载配置 (有概率VPN断连) 丢失DNS缓存(TTL), 严重影响规则匹配效率 可能会打断活动的网络连接 (下载中断) 基于以上弊端, 本文将跳过(开启/关闭)模块的实现方式. 第一步: 配置捷径脚本 Surge内新建Cron类型脚本, Cron表达式填写 0 0 1 1 * 脚本名暂且设置为“APP防火墙”, 编辑并填入以下脚本, 保存后将该Cron脚本禁用(左划) APP防火墙.js123const data = $intent.parameter;const write = $persistentStore.write(data, &quot;APP_BJ&quot;);$done(); 以下为科普脚本代码的具体用途及原理, 请选择性阅读. APP防火墙.js1const data = $intent.parameter; 在JS语法中, 声明一个名为data的常量, 值为$intent.parameter, 该API实际内容为读取Surge捷径运行后传入的字符串; 如果Surge捷径的参数留空, 则该API实际内容为空字符串 APP防火墙.js1const write = $persistentStore.write(data, &quot;APP_BJ&quot;); 在JS语法中, 声明一个名为write的常量, 值为Surge的内部函数, 该函数的实际用途为持久化储存, 接受2个参数, 需要写入的数据(字符串类型), 以及一个固定的读取键(字符串类型) 该行用途: 写入(储存)上一行代码中名为data的常量的值, 读取键为”APP_BJ” APP防火墙.js1$done(); 立即调用Surge内部函数, 该函数的实际用途为退出脚本执行; 使用Surge执行脚本时, 该API不可省略. 第二步: 配置捷径自动化 打开”捷径” &gt; 自动化 &gt; 加号 &gt; 创建个人自动化 &gt; APP &gt; 选取”已打开” &gt; 手动选取除了”设置”外的所有APP &gt; 添加操作, 搜索”Surge”, 选取运行脚本 &gt; 展开 &gt; 脚本名为前面设置的”APP防火墙”, 参数留空 &gt; 下一步 &gt; 关闭”运行前询问” &gt; 完成 重复第1步的过程, 不同的是, 需要选取APP已关闭时运行捷径, 并且需要把Surge动作里的参数填写 1 (重要) 第三步: 配置规则脚本 Surge内新建Rule类型脚本, 脚本名暂且设置为”RULE防火墙”, 编辑并填入以下脚本并保存 RULE防火墙.js12const read = $persistentStore.read(&quot;APP_BJ&quot;);$done({ matched: Boolean(read) }); 以下为科普脚本代码的具体用途及原理, 请选择性阅读. RULE防火墙.js1const read = $persistentStore.read(&quot;APP_BJ&quot;); 在JS语法中, 声明一个名为read的常量, 值为Surge的内部函数, 该函数的实际用途为持久化读取(读取之前所写入的数据), 接受1个参数: 读取键 (字符串类型) 该行用途: 读取捷径脚本所写入”APP_BJ”键的持久化数据 RULE防火墙.js1$done({ matched: Boolean(read) }); 立即调用Surge内部函数, 该函数的实际用途为退出脚本执行, 由于是Rule脚本(使用脚本进行规则判定), 需要额外返回一个对象键值对，对象属性键为 matched, 值为布尔值(true/false)表示是否匹配该规则; 在当前代码中, JS内部函数Boolean()用于转换布尔值 该行用途: 退出脚本并判断是否匹配规则, 如果常量的数据(捷径脚本所写入的数据), 能够转换为true, 则返回true(匹配规则), 否则返回false(不匹配规则) 第四步: 配置逻辑规则规则定义 逻辑规则可将多个规则相互嵌套(包含逻辑规则), 用于复杂的规则判断. 1AND, ((#子规则1), (#子规则2), (#子规则3)), Policy AND运算符表示: 如果所有子规则都匹配，则该规则匹配 1OR, ((#子规则1), (#子规则2), (#子规则3)), Policy OR运算符表示: 如果子规则其中一个匹配，则该规则匹配 1NOT, ((#子规则)), Policy NOT运算符表示: 如果子规则不匹配，则该规则匹配 理解以上定义后, 我们可以使用逻辑规则和脚本规则共同决定网络请求是否需要拦截, 并设置白名单 配置规则 编辑Surge配置文件, 在[Rule]段落放入以下逻辑规则: [Rule]1AND,((NOT,((OR,((USER-AGENT,Surge*), (RULE-SET,https://raw.githubusercontent.com/NobyDa/Script/master/Surge/Apple.list))))), (SCRIPT,RULE防火墙)),REJECT 以上逻辑规则已包含Apple/Surge白名单(匹配后放行), 可匹配绝大多数系统App或Surge自身发送的请求 可自行配置白名单规则: Surge内点击该AND规则 &gt; NOT &gt; OR &gt; 新增 &gt; 添加规则或规则集 &gt; 完成 网络请求经过Surge规则系统时, 该规则判断逻辑: 至此, 已实现方案一需求: 打开手机内任何一个APP时(前台), 放行网络请求 关闭任何一个APP时(后台), 拦截所有请求 拦截的请求可以设置白名单 方案一: 注意事项 该方案仅针对有特殊需求的用户设计, 一般用户不应该使用. 因为会产生各种副作用, 包括但不限于: iOS14桌面/负一屏小组件无法联网 Surge后台定时脚本任务无法联网 基于主屏幕的Web, 例如BoxJS、Sub-Store 无法联网 低版本iOS系统或老旧机型打开APP时,可能会无法触发捷径自动化进而造成APP无法联网 前三点虽然可以抓取请求配置规则白名单, 但相对来说比较麻烦. 捷径通知 当我们设定 iOS 捷径内的「个人自动化」功能时, 虽然可以关闭 “运行前询问” 但是当自动化脚本开始执行时, 系统会通知提醒自动化已开始执行. 如果不想每次都收到这种通知, 那么我们其实可以通过一个系统BUG来关闭, 具体可点击此处查看具体方法; 有一点需要注意, 捷径通知关闭后如果运行的捷径里包含通知动作, 则该捷径将直接中断. 实现方案二由于方案一过于暴力, 方案二应运而生. 该方案主要为本文的中心需求. 需求: 从蜂窝网络连接WiFi的瞬间, 15秒内拦截所有请求, 15秒后放行网络请求 拦截的请求可以设置白名单 思路: 网络环境改变时, 触发运行Surge事件(Event)类型脚本, 脚本内容为: 如果从蜂窝网络切换至WiFi, 则写入当前时间戳数据, 再使用逻辑规则和脚本规则共同决定15秒内的网络请求是否需要拦截 该方案完全基于Surge, 如果您 “不想了解具体原理“ 或者 “想跳过繁琐的配置“, 可使用懒人Surge模块一键配置, 模块地址: 1https://gist.githubusercontent.com/NobyDa/fb026a6d01fec146bd451d01b0c973d5/raw/NetworkFirewall.sgmodule 已包含Apple/Surge白名单(匹配后放行) 第一步: 配置事件脚本 Surge内新建Event类型脚本, 脚本名暂且设置为 “WIFI防火墙” , 事件名设置为 “network-changed” , 编辑并填入以下脚本并保存 WIFI防火墙.js1234567891011const network = $network.wifi.ssid;const currentTime = Date.now();$httpAPI(&quot;GET&quot;, &quot;v1/traffic&quot;, null, (body) =&gt; { if (network &amp;&amp; (currentTime / 1000) - body.startTime &gt;= 3) { const time = JSON.stringify(currentTime); const addTime = $persistentStore.write(time, &quot;WiFi_Timer&quot;); $notification.post('防火墙开始拦截', '', `已从蜂窝网络切换至 ${network}`); } $done();}) 以下为科普脚本代码的具体用途及原理, 请选择性阅读. WIFI防火墙.js1const network = $network.wifi.ssid; 在JS语法中, 声明一个名为network的常量, 值为Surge内部API, 该$network实际内容为当前网络状态的总览. (加入.wifi.ssid则表示仅提取当前WIFI名称) 该行用途: 事件脚本运行后读取当前网络的WIFI名称 WIFI防火墙.js1const currentTime = Date.now(); 在JS语法中, 声明一个名为currentTime的常量, 值为JS中的内部函数, 该函数返回Unix时间戳 WIFI防火墙.js1$httpAPI(&quot;GET&quot;, &quot;v1/traffic&quot;, null, (body) =&gt; { ... }) 立即调用Surge内部函数并传入四个参数(method: String, path: String, body: Object, callback: Function), 该$httpAPI暂时没有官方文档, 但与HTTP API用法类似, 具体可查看HTTP API官方文档 该行用途: 由于Surge每次开启VPN时, 都会触发一次network-changed事件脚本, 为了避免错误触发导致的问题, 以上$httpAPI回调的参数将返回开启VPN的时间, 用于稍后的判断 WIFI防火墙.js1if (network &amp;&amp; (currentTime / 1000) - body.startTime &gt;= 3) { ... } 在JS语法中, 表示条件语句块; 我们经常需要根据不同条件来执行不同的代码, 以上条件语句可以实现这一点. 该行用途: 脚本运行后, 如果当前为WiFi环境 并且”当前时间“ 减 “开启VPN时间“ 大于等于3秒, 则执行花括号内{ … }的代码, 否则跳过 WIFI防火墙.js1const time = JSON.stringify(currentTime); 在JS语法中, 声明一个名为time的常量, 值为JS中的内部函数, 该函数实际用途为”将对象或值转换为JSON字符串”; 在当前代码中, 表示转换名为currentTime的常量 (Unix时间戳) 该行用途: 读取声明的Unix时间戳(数字类型), 并将它转换成字符串类型, 便于储存 WIFI防火墙.js1const addTime = $persistentStore.write(time, &quot;WiFi_Timer&quot;); 在JS语法中, 声明一个名为addTime的常量, 值为Surge的内部函数, 该函数的实际用途为持久化储存, 接受2个参数, 需要写入的数据(字符串类型), 以及一个固定的读取键(字符串类型) 该行用途: 写入(储存)名为time常量的值(Unix时间戳), 读取键为”WiFi_Timer” WIFI防火墙.js1$notification.post('防火墙开始拦截', '', `已从蜂窝网络切换至 ${network}`); 立即调用Surge内部函数推送一个Surge通知, 并传入三个参数, 分别为标题, 副标题, 内容. 三个参数仅接受字符串类型 WIFI防火墙.js1$done(); 立即调用Surge内部函数, 该Surge函数的实际用途为退出脚本执行; 使用Surge执行脚本时, 该API不可省略. 第二步: 配置规则脚本 Surge内新建Rule类型脚本, 脚本名暂且设置为”TIME防火墙”, 编辑并填入以下脚本并保存 TIME防火墙.js123456789101112let block = { matched: false };const readTimer = $persistentStore.read(&quot;WiFi_Timer&quot;);if (readTimer) { const currentTime = Date.now(); const markTime = parseInt(readTimer); if (currentTime - markTime &lt;= 15000) { block.matched = true; } else { const delTime = $persistentStore.write(&quot;&quot;, &quot;WiFi_Timer&quot;); }}$done(block); 以下为科普脚本代码的具体用途及原理, 请选择性阅读. TIME防火墙.js1let block = { matched: false }; 在JS语法中, 声明一个名为block的变量, 并初始化对象 该行用途: 由于是Rule脚本(使用脚本进行规则判定), 脚本结束时需要额外返回一个对象键值对表示是否匹配该规则; 此处是为了节省代码(重复段), 避免多次使用$done. 初始化的对象键值对默认为false(不匹配规则), 如果重新赋值(改变)为true则匹配规则 TIME防火墙.js1const readTimer = $persistentStore.read(&quot;WiFi_Timer&quot;); 在JS语法中, 声明一个名为readTimer的常量, 值为Surge的内部函数, 该函数的实际用途为读取之前所写入的数据, 接受1个参数: 读取键(字符串类型) 该行用途: 读取事件脚本所写入”WiFi_Timer”键的持久化数据(Unix时间戳) TIME防火墙.js1if (readTimer) { ... } 如果名为readTimer的常量可以转换成true(有Unix时间戳), 则执行花括号内{ … }的代码, 否则跳过 TIME防火墙.js1const currentTime = Date.now(); 在JS语法中, 声明一个名为currentTime的常量, 值为JS的内部函数, 该函数实际的值为当前Unix时间戳(数字类型) TIME防火墙.js1const markTime = parseInt(readTimer); 在JS语法中, 声明一个名为markTime的常量, 值为JS的内部函数, 该函数在当前代码中的实际用途为 将”字符串” 转换成 “数字”类型, (转换名为readTimer常量的值) 该行用途: 读取事件脚本所写入的Unix时间戳, 并将它转换成数字类型, 便于判断 TIME防火墙.js1234567if (currentTime - markTime &lt;= 15000) { //代码块1 //重新赋值(改变)block变量中matched键的值, true表示匹配规则 block.matched = true; } else { //代码块2 //清除事件脚本所写入的Unix时间戳 const delTime = $persistentStore.write(&quot;&quot;, &quot;WiFi_Timer&quot;); } 如果当前Unix时间戳 减 事件脚本所保存的Unix时间戳 小于等于15000毫秒(15秒), 则执行代码块1的代码: 否则则执行代码块2的代码 TIME防火墙.js1$done(block); 立即调用Surge内部函数, 该函数的实际用途为退出脚本执行, 并返回block变量(脚本第一行)表示是否匹配规则 第三步: 配置逻辑规则规则定义在方案一中的配置逻辑规则章节里有详细描述, 这里不再赘述 编辑Surge配置文件, 在[Rule]段落放入以下逻辑规则: [Rule]1AND,((NOT,((OR,((USER-AGENT,Surge*), (RULE-SET,https://raw.githubusercontent.com/NobyDa/Script/master/Surge/Apple.list))))), (SCRIPT,TIME防火墙)),REJECT 以上逻辑规则已包含Apple/Surge白名单(匹配后放行), 可匹配绝大多数系统App或Surge自身发送的请求 可自行配置白名单规则: Surge内点击该AND规则 &gt; NOT &gt; OR &gt; 新增 &gt; 添加规则或规则集 &gt; 完成 网络请求经过Surge规则系统时, 该规则判断逻辑: 至此, 已实现方案二需求: 从蜂窝网络连接WiFi的瞬间, 15秒内拦截所有请求, 15秒后放行网络请求 拦截的请求可以设置白名单 方案二: 注意事项 该方案相对来说比较收敛, 配置后对正常使用几乎没有影响, 适合大多数有隐私需求的用户, 但有几点需要注意: 如果您的WIFI路由器信号不稳定, 则可能会错误触发事件脚本导致间歇性断网. 从WiFi切换至蜂窝可能会触发事件脚本导致断网. (小概率) 从蜂窝切换至WiFi的瞬间, 可能会漏掉极少部分网络请求, 导致极少部分的网络请求拦截失败. 无法阻止手动打开系统设置查看WiFi列表所触发的网络请求. 前3点是Surge自身触发事件脚本的逻辑所决定的, 无法改进; 如果您在意, 可以选择同时配置方案一和方案二, 以掌握绝对的APP联网权限. 结语本文内容相对来说比较硬核, 所列出的只是极其小众的需求, 非科班出身的同学可能会有理解障碍, 但完全理解后你会发现非常有意思. Surge脚本规则执行效率极高, 在笔者的测试环境中(iPhone12), 绝大多数网络请求经过逻辑规则+脚本规则仅耗时5ms以内, 某些复杂请求可能会在10ms以内, 基本不必担心因使用脚本规则而带来的性能问题. 文章内的需求仅仅只是Surge高级用法的其中之一; 借助Surge进行全面的网络接管并使用捷径、规则、脚本可以建立出无限可能性. 数据时代, 隐私安全将会带来巨大挑战, 而在中国, 有这样的一种软件, 不绑定手机将无法使用或受到限制; 之后他们发现所有用户都绑定了手机, 然后他们得出一个结论: 中国人更愿意用隐私换取效率. 这种论调放在一百年前大概就是 “工人愿意选择工作16个小时, 放弃所有休息时间多赚钱养家糊口”. 殊不知可悲的是, 很多时候人们并没有别的选择. 不是我们不在乎隐私, 而是没有能力去抵抗. 以上","link":"/2021/06/08/Surge_network_firewall/"},{"title":"Hello World","text":"欢迎来到NobyDa’s Blog, 这是搭建博客以来的第一篇文章. 作为一名合格的开发者, “Hello World”最具代表意义, 象征着一切的开始. 由来最近想分享一些App使用心得, google找了一圈发现找不到满意的markdown博客平台, 要么缺少种种功能, 要么页面风格不喜欢. 所以经过综合考虑, 决定动手自建. 自建博客有很多优势, 比如可以完全自定义一些插件或功能, 最主要的是完全可以满足我的审美. 在踩了许多坑之后, 终于搭建起了基于Hexo的个人博客, Hexo是一款基于Node.js的静态博客框架, 对于我来说比较友好. 内容该博客主要分享一些App高级使用技巧, 例如Surge, QuantumultX, 以及个人的日常; 以后也可能会写JavaScript教程. 最后, 希望建了博客之后, 自己能坚持把内容写下去吧.","link":"/2021/06/06/hello-world/"}],"tags":[{"name":"Surge","slug":"Surge","link":"/tags/Surge/"},{"name":"QuantumultX","slug":"QuantumultX","link":"/tags/QuantumultX/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[{"name":"脚本开发","slug":"脚本开发","link":"/categories/%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91/"},{"name":"APP高级使用技巧","slug":"APP高级使用技巧","link":"/categories/APP%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"Surge","slug":"APP高级使用技巧/Surge","link":"/categories/APP%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/Surge/"}]}